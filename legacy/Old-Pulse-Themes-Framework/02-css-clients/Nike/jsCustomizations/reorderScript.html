<script>
var config = {
  8960 : 8,
  8961 : 2,
  8962 : 3,
  8963 : 4,
  8964 : 5,
  8965 : 6,
  8971 : 7,
  9197 : 2,
  9249 : 9,
};
var config = {
  9772 : 1
};
var reorderEls = function(config){
window.totalG = [];
    var getPreviousSibling = function (elem, className) {

      // Get the next sibling element
      var sibling = elem.previousElementSibling;

      // If there's no className, return the first sibling
      if (!className) return sibling;

      // If the sibling matches our className, use it
      // If not, jump to the next sibling and continue the loop
      while (sibling) {
        if (sibling.classList.contains(className)) return sibling;
        sibling = sibling.previousElementSibling;
      }

    };
    var getNextSibling = function (elem, className) {

      // Get the next sibling element
      var sibling = elem.nextElementSibling;

      // If the sibling matches our className, use it
      // If not, jump to the next sibling and continue the loop
      while (sibling) {
        if (sibling.classList.contains(className)) return sibling;
        sibling = sibling.nextElementSibling;
      }

    };
    var order = 1,
        elGroup = [],
        q,
        qId,
        baseEl;
    var overallOrder = 1;

    var qs = PulseInsightsObject.survey.questions.slice(),
        keys = Object.keys(config);
    var index;
    for (var i = 0; i < keys.length; i++) {
      for (var j = 0; j < qs.length; j++) {
        if(qs[j].id == keys[i]){
          index = j;
          break;
        }
      }
      var q = qs.splice(index, 1);
      qs.splice((config[keys[i]] - 1),0 ,  q[0])
    }
    for (var i = 0; i < qs.length; i++) {
      elGroup = [];
      q = qs[i];
      qId = q.id;
      //get question el

      baseEl = PulseInsightsObject.survey.widgetContainer.querySelector('._pi_answers_container[data-question-id="'+ qId +'"]');

      // if(optional == "f"){
        //need to handle optional stuff
      // }

      // console.log(i);
      // console.log(q);
      if(q.before_question_text !== "" && q.before_question_text !== null && q.question_type == "single_choice_question" && q.button_type === 1){
        // get before question el
        console.log('bq');
        elGroup.push(getPreviousSibling(baseEl, 'pi_header_before'));
      }
      // if(q.question_type != "custom_content_question"){
        console.log('q');
        console.log(q);
        console.log(baseEl);
        elGroup.push(getPreviousSibling(baseEl, '_pi_question'));
      // }
      if(q.after_question_text !== "" && q.after_question_text !== null && q.question_type == "single_choice_question" && q.button_type === 1){
        // get after question el
        console.log('aq');
        elGroup.push(getPreviousSibling(baseEl, 'pi_header_after'));
      }



      if(q.before_answers_count != "0" && q.before_answers_items != null && q.question_type == "single_choice_question" && q.button_type === 1){
        // get before answer el
        console.log('ba');
        elGroup.push(getPreviousSibling(baseEl, '_pi_scale_container_before'));
      }

      console.log('be');
      elGroup.push(baseEl);

      if(q.after_answers_count != "0" && q.after_answers_items != null && q.question_type == "single_choice_question" && q.button_type === 1){
        // get after answer el
        console.log('aa');
        elGroup.push(getNextSibling(baseEl, '_pi_scale_container_after'));
      }
      //
      console.log(elGroup);
      console.log('|||||||||');

      for (var j = 0; j < elGroup.length; j++) {
        elGroup[j].style.setProperty("order", overallOrder.toString());
        overallOrder++;
      }

    totalG.push(elGroup);
    }
console.log(totalG);
document.querySelector('._pi_all_questions_submit_button_container').style.setProperty("order", (document.querySelector("._pi_widgetContentContainer").childNodes.length + 1) );
};
setTimeout(function(){
reorderEls(config);
}, 500);

</script>
